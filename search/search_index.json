{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what-is-baddns","title":"What is BadDNS?","text":"<p>BadDNS is a library, supporting the detection of a a wide range of DNS related security issues. It is designed from day one to work within BBOT, which allows you to utilize it at massive scale seamlessly as part of the domain discovery process. </p> <p>It's also a fully functional standalone command-line tool, useful for any time you want to assess a single domain.</p>"},{"location":"#modular","title":"Modular","text":"<p>BadDNS is modular. This means new functionality can be added easily in the future, and its also easy to customize which modules you want to use and which you don't. Currently, BadDNS has 7 modules, which are explored in the Modules Section. </p>"},{"location":"#cli","title":"CLI","text":"<p>The standalone CLI is capable of running all of the modules, or any combination of individual modules. It can also support defining a custom signature folder, and the use of custom nameservers.</p>"},{"location":"#usage","title":"Usage","text":"<pre><code>positional arguments:\n  target                subdomain to analyze\n\noptions:\n  -h, --help            show this help message and exit\n  -n CUSTOM_NAMESERVERS, --custom-nameservers CUSTOM_NAMESERVERS\n                        Provide a list of custom nameservers separated by comma.\n  -c CUSTOM_SIGNATURES, --custom-signatures CUSTOM_SIGNATURES\n                        Use an alternate directory for loadings signatures\n  -l, --list-modules    List available modules and their descriptions.\n  -m MODULES, --modules MODULES\n                        Comma separated list of module names to use. Ex: module1,module2,module3\n  -d, --debug           Enable debug logging\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Installation is simple, since BadDNS is packaged as a pypi package. Simply use pip: <code>pip install baddns</code>. Alternatively, you can git clone the repo: <code>https://github.com/blacklanternsecurity/baddns.git</code> and then use <code>poetry</code>.</p> <ul> <li>First <code>poetry install .</code> from the baddns folder</li> <li>Run Baddns with <code>poetry run baddns</code></li> </ul>"},{"location":"#bbot","title":"BBOT","text":"<p>BadDNS is also BBOT module, and if you are trying to run it at any kind of scale, this is the preferred way to use it. If you wanted to use BBOT to enumerate as many subdomains as possible and run BadDNS against all of them, you could use this command:</p> <pre><code>bbot -m baddns -f subdomain-enum target-base-domain.com\n</code></pre> <p>No installation necessary here, BBOT's dependency management system will take care of that for you.</p> <p></p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#cname","title":"cname","text":"<p>The <code>cname</code> modules check for \"Dangling\" CNAME records, and then interrogates them for takeover opportunities. </p> <p>A dangling DNS record refers to a record which points to a resource that doesn't exist anymore. In the context of a subdomain takeover, this can manifest in several ways. For instance, consider a record pointing to an *.azurewebsites.net instance (for example) that isn't registered anymore, and results in an NXDOMAIN result. This situation allows someone else to register the same instance with Azure and redirect the dangling CNAME record to their resource.  It could also point to a service (such as WordPress) that resolves but results in a particular error message or status code indicating that the subdomain is available for use within the service.</p> <p>All of the specific knowledge for each of these services is contained within signatures. When a dangling CNAME is discovered, it will be checked against every signature for a match. If a match is found, it is considered a <code>VULNERABILITY</code>. If not, it might still be interesting (it could be an undiscovered new type of takeover) and will be reported accordingly. When using BadDNS via the BBOT module, these instances are reported as a <code>FINDING</code> for a generic dangling record.</p> <p>Since many takeover detections depend on strings within HTTP content, BadDNS performs HTTP requests to its targets, in addition to DNS queries.</p> <p>WHOIS requests are also made, which are used to determine the expiration date of the CNAME's base domain target. The focus of BadDNS isn't solely on subdomains; taking over a base domain inherently grants control over all its subdomains.</p>"},{"location":"modules/#ns","title":"ns","text":"<p>NS records can also be subject to dangling issues, similar to CNAME records. A signature is necessary to determine if the dangling NS record is exploitable. Additionally, generic dangling NS records are reported, as they might reveal a new type of takeover that has not yet been investigated.</p> <p>To identify a \"Dangling\" NS record, we examine NS records that exist without a corresponding SOA (Start of Authority) record. As noted in the research notes, this process can be challenging due to variations in DNS server behavior. Some of them will lie to you about an NS record they find if they can't find an SOA record, effectively concealing the dangling NS records. To deal with this, the <code>ns</code> module mimicks the behavior of an actual DNS server making a recursive lookups, starting a the TLD (top-level domain). </p> <p>If it finds any dangling NS records, they are checked against every <code>ns</code> signature for a match.</p>"},{"location":"modules/#nsec","title":"nsec","text":"<p>NSEC walking refers to a method used by attackers to enumerate the contents of a DNS zone when DNSSEC (DNS Security Extensions) is implemented. DNSSEC was designed to add an extra layer of security to the DNS by validating the authenticity of the responses. It uses two record types for this purpose: NSEC (Next Secure Record) and NSEC3. These records provide proof of non-existence of a DNS record, helping to prevent common attacks like cache poisoning.</p> <p>However, NSEC records inadvertently introduce a vulnerability. An NSEC record not only indicates that a specific DNS record does not exist but also reveals the next valid domain name in the DNS zone. By continuously querying for non-existent records, an attacker can use the responses to gradually map the entire set of domain names in a zone, a technique known as NSEC walking. This process can uncover subdomains and other DNS entries that might not be intended for public knowledge.</p> <p>The NSEC module looks for instances where NSEC records are present, and then attempts to actually \"walk\" the records, and then report all of the domains it finds in the process.</p>"},{"location":"modules/#references","title":"references","text":"<p>What happens if a website is pointing to an external source for it's Javascript or CSS, and that external source can be taken over? The best cross-site scripting you could ever ask for. The references module does just that, wrapping the <code>cname</code> module behind the scenes and sending any CSS/JS domains found in the target's HTML content for analysis. If a match is found, it's emitted with the added context of the page it was found in.</p>"},{"location":"modules/#txt","title":"txt","text":"<p>TXT records in DNS serve a variety of purposes, one common use being domain ownership verification. A service may require setting a specific TXT record, a task achievable only by the domain owner, thereby confirming ownership. However, the utilization of TXT records extends far beyond this. They are often employed for a myriad of custom, sometimes unconventional, purposes.</p> <p>What happens when a TXT record just happens to contain a domain/subdomain that just happens to be vulnerable to a takeover?. Who knows. This type of detection is the least likely to be exploitable - but if it is, it could be very interesting. If you get a detection here, it's worth doing the takeover and just spinning up a server and seeing what requests get sent to it.</p> <p>Behind the scenes, when a domain is found in a TXT record, the <code>txt</code> module actually sends the domain/subdomain to the <code>cname</code> module where it gets processed just like any other subdomain. If there's a hit, its emitted with the added context of the TXT record it was found in. </p>"},{"location":"modules/#mx","title":"mx","text":"<p>Taking over a dangling MX record can have significant consequences. If an organization has multiple MX records and some of them are still functional, they may not notice that there is a dangling record present. An attacker who is able to gain control of a domain the dangling record is pointing to can start receiving a portion of an organization's email. Although the impact of control of an email server heavily depends on the priority settings for the various mail servers (emails may only go to lower priority servers if the higher priority servers go down), it can have a significant impact. In addition to the partial loss of email functionality, credentials or other sensitive information could be captured if they are shared in the intercepted emails.</p> <p>A crafty attacker might even resend messages they siphon off, so the organization never notices a problem, and then silently gain access to a portion of their emails indefinitely.</p>"},{"location":"modules/#zonetransfer","title":"zonetransfer","text":"<p>Zone transfers are a legitimate function used by DNS servers to synchronize DNS record information between a primary DNS server and its secondary servers. This synchronization ensures that all servers have an up-to-date copy of the DNS records, which are crucial for routing internet traffic to the correct locations.</p> <p>While essential for DNS operation, zone transfers can pose significant security risks if not properly secured. An unrestricted zone transfer can expose all DNS records of a domain to unauthorized parties. Although rare, when they do occur they typically yield every domain for the organization, which can be a gold mine for an attacker trying to perform recon against a target.</p> <p>The <code>zonetransfer</code> module will interrogate the name server(s) that are authoritative for the target domain and attempt a zone transfer. If successful, it will also harvest all of the available records and present them within the result.</p>"},{"location":"research/","title":"Research","text":"<p>Coming Soon</p>"},{"location":"resources/","title":"Resources","text":"<p>If you are still not solid on your understanding of subdomain takeover, the following resources should help get you up to speed:</p> <ul> <li>HackTricks - Domain/Subdomain Takeover</li> <li>Hackerone - Guide to Subdomain Takeovers</li> <li>OWASP Web Application Security Testing - Test for Subdomain Takeover</li> </ul> <p>One this BadDNS doesn't help with very much is the actual takeover process, once a valid takeover is detected. This varies significantly from takeover-to-takeover. There are some excellent resources focused on the exploitation side of subdomain takeovers. </p> <p>First and foremost, can-i-take-over-xyz. The issues pages within this GitHub repo contain most of the current research on individual takeovers.</p> <p>Another excellent resource for some specific cloud provider based takeovers are the \"GoDiego\" blog posts, by @secfaults.</p> <ul> <li>Subdomain Takeover in Azure</li> <li>Subdomain Takeover in AWS</li> </ul>"},{"location":"signatures/","title":"Signatures","text":"<p>The signatures used by several BadDNS modules are ultimately sourced from two main projects:</p> <ul> <li>Nuclei Templates. The nuclei templates pertaining to subdomain takeovers are automatically converted and imported into BadDNS</li> <li>dnsReaper. Another excellent project devoted to discovering subdomain takeovers, whose signatures are imported and converted into BadDNS.</li> </ul> <p>GitHub automation pipelines monitor these projects for any new signatures. If they are found, they are converted into BadDNS's format. Tests will be run against the converted signatures. If the tests pass and the signatures look good, they can be imported into BadDNS with one click by the maintainers.</p> <p>BadDNS can also maintain it's own, unique, signatures when necessary.</p> <p>Rather than contribute further to the fragmentation of DNS-based signatures by creating another set of them, BadDNS aims to utilize and support existing repositories of signatures. </p> <p>Currently, the ultimate source of many of these signatures is the <code>https://github.com/EdOverflow/can-i-take-over-xyz</code> repository. The issues section of this repo has become a centralized discussion place for signatures. Many of these discussions are used to create signatures within Nuclei. Ultimately, these Nuclei signatures are converted and used within BadDNS.</p> <p>We highly encourage contributions to the signatures on these projects and to the discussions on <code>can-i-take-over-xyz</code>, as ultimately these are fed into BadDNS and benefit the entire community.</p>"}]}